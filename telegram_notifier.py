import requests
from typing import Dict
from config import config


class TelegramNotifier:
    """
    Sends premium formatted trading signals to Telegram
    """

    # ------------------------------------------------------------------
    # MarkdownV2 escape
    # ------------------------------------------------------------------
    @staticmethod
    def _escape_markdown(text: str) -> str:
        """
        Escape special characters for Telegram MarkdownV2.
        Reserved: _ * [ ] ( ) ~ ` > # + - = | { } . ! :
        """
        special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>',
                         '#', '+', '-', '=', '|', '{', '}', '.', '!', ':']
        for ch in special_chars:
            text = text.replace(ch, f'\\{ch}')
        return text

    # ------------------------------------------------------------------
    # Public high-level helpers
    # ------------------------------------------------------------------
    @staticmethod
    def send_signal(signal: Dict):
        """Send a trading signal to the configured chat."""
        direction_emoji = "ğŸŸ¢" if signal['direction'] == "LONG" else "ğŸ”´"
        fire_emoji = "ğŸ”¥" if signal['score'] >= 80 else "âš¡"

        pair = signal['pair']
        direction = signal['direction']
        score = signal['score']
        leverage = signal['leverage']
        entry = signal['entry']
        sl = signal['sl']
        tp1 = signal['tp1']
        tp2 = signal['tp2']
        rsi = signal['rsi']
        adx = signal['adx']
        mtf = signal['mtf_trend']
        volume = signal['volume_surge']
        mode = signal.get('mode', 'UNKNOWN')
        timeframe = signal.get('timeframe', 'N/A')
        timestamp = signal['timestamp']

        message = f"""
{fire_emoji} *{direction} SIGNAL* {direction_emoji}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ğŸ“Š PAIR:* `{pair}`
*ğŸ’¯ SCORE:* {score}/100
*â±ï¸ TIMEFRAME:* {timeframe}
*ğŸ“ˆ LEVERAGE:* {leverage}x

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ğŸ¯ ENTRY:* â‚¹{entry:,.2f}
*ğŸ›‘ STOP LOSS:* â‚¹{sl:,.2f}
*âœ… TP1:* â‚¹{tp1:,.2f}
*âœ… TP2:* â‚¹{tp2:,.2f}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ğŸ“‰ RSI:* {rsi}
*ğŸ“Š ADX:* {adx}
*ğŸ”„ MTF:* {mtf}
*ğŸ“¦ Volume:* {volume}x

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*âš™ï¸ MODE:* {mode}
*â° TIME:* {timestamp}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
_Auto\\-generated by ARUN Bot ğŸ¤–_
        """.strip()

        TelegramNotifier._send_message(
            TelegramNotifier._escape_markdown(message),
            parse_mode='MarkdownV2'
        )

    @staticmethod
    def send_alert(title: str, message: str):
        """Send a simple alert."""
        text = f"âš ï¸ *{title}* âš ï¸\n\n{message}".strip()
        TelegramNotifier._send_message(
            TelegramNotifier._escape_markdown(text),
            parse_mode='MarkdownV2'
        )

    @staticmethod
    def send_startup_message():
        """Notify that the bot has started."""
        mode_display = ', '.join(config.ACTIVE_MODES) if config.MULTI_MODE_ENABLED else config.MODE
        auto_trade = 'âœ… ON' if config.AUTO_TRADE else 'âŒ OFF'
        pairs_list = ', '.join(config.PAIRS)

        message = f"""
ğŸš€ *ARUN BOT STARTED* ğŸš€

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*âš™ï¸ Configuration:*
â€¢ Mode: {mode_display}
â€¢ Auto Trade: {auto_trade}
â€¢ Max Signals: {config.MAX_SIGNALS_PER_DAY}/day
â€¢ Pairs: {len(config.PAIRS)}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ğŸ“Š Trading Pairs:*
{pairs_list}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Bot is now monitoring markets ğŸ‘€
        """.strip()

        TelegramNotifier._send_message(
            TelegramNotifier._escape_markdown(message),
            parse_mode='MarkdownV2'
        )

    @staticmethod
    def send_daily_summary(stats: Dict):
        """End-of-day summary."""
        mode_display = stats.get('mode', 'N/A')
        signals_today = stats.get('signals_today', 0)
        success_rate = stats.get('success_rate', 'N/A')

        breakdown = ""
        if 'mode_breakdown' in stats:
            breakdown = "\n*Breakdown:*\n"
            for mode, count in stats['mode_breakdown'].items():
                breakdown += f"â€¢ {mode}: {count}\n"

        message = f"""
ğŸ“Š *DAILY SUMMARY* ğŸ“Š

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*Signals Generated:* {signals_today}
*Mode:* {mode_display}
*Success Rate:* {success_rate}{breakdown}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
See you tomorrow! ğŸŒ™
        """.strip()

        TelegramNotifier._send_message(
            TelegramNotifier._escape_markdown(message),
            parse_mode='MarkdownV2'
        )

    # ------------------------------------------------------------------
    # Low-level sender
    # ------------------------------------------------------------------
    @staticmethod
    def _send_message(text: str, parse_mode: str = 'MarkdownV2'):
        """Actually transmit the message."""
        if not config.TELEGRAM_BOT_TOKEN or not config.TELEGRAM_CHAT_ID:
            print("âš ï¸  Telegram credentials not configured")
            print(f"Message: {text}")
            return

        url = f"https://api.telegram.org/bot{config.TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': config.TELEGRAM_CHAT_ID,
            'text': text,
            'parse_mode': parse_mode,
            'disable_web_page_preview': True
        }

        try:
            r = requests.post(url, data=payload, timeout=10)
            r.raise_for_status()
            print("âœ… Telegram message sent")
        except requests.exceptions.RequestException as exc:
            print(f"âŒ Telegram send failed: {exc}")
            if hasattr(exc, 'response') and exc.response is not None:
                print(f"   Response: {exc.response.text}")

    # ------------------------------------------------------------------
    # Connection test
    # ------------------------------------------------------------------
    @staticmethod
    def test_connection():
        """Verify bot token validity."""
        try:
            url = f"https://api.telegram.org/bot{config.TELEGRAM_BOT_TOKEN}/getMe"
            r = requests.get(url, timeout=5)
            r.raise_for_status()
            info = r.json()
            if info.get('ok'):
                print(f"âœ… Telegram bot connected: @{info['result']['username']}")
                return True
            else:
                print("âŒ Telegram bot connection failed")
                return False
        except requests.exceptions.RequestException as exc:
            print(f"âŒ Telegram test failed: {exc}")
            return False
